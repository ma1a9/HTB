# <span style="color: blue;">Example 1</span>
![ea7117bb322c8c29b3f2af1acf346fe6.png](../../_resources/ea7117bb322c8c29b3f2af1acf346fe6.png)

# <span style="color: blue;">Example 2</span>
この状況では、開発者は文字列比較の脆弱性を時間的に一定にしないようにしています。これは、ウェブページが入力された文字列を、エラーを見つけるまで一文字ずつ分析することを意味します。

もし、ある文字が解析されるのにかかる時間を記録すれば、それが正しいのか間違っているのかがわかります（正しい場合は、エラーを見つける前に次の文字に移るので、エラーを取り出すのにもっと時間がかかります）。  
また、以下の自動化されたPythonスクリプトを使用して、同じ結果を得ることができます。   
 [http-auth-timming.py](https://gist.github.com/mgeeky/57e866604942f1824da310982c46da84)   
 
 # <span style="color: blue;">Example 3</span>
 これは Cookie 操作のエクスプロイトです。ログインすると、サーバーは user1 という名前の Cookie を値 user1 で設定します。
 ![f8840f9e47308c314a5a529fd1ca0aee.png](../../_resources/f8840f9e47308c314a5a529fd1ca0aee.png)
 ![291f83f515f30fc93cdf19746714fa5c.png](../../_resources/291f83f515f30fc93cdf19746714fa5c.png)
 Cookie エディターのブラウザー拡張機能を使用して値をuser1からadminに変更し、サイトのホーム ボタンをクリックしてExample3を再選択するだけです。   
 ![52cf93477ba36a8c88e76feb26d69d7d.png](../../_resources/52cf93477ba36a8c88e76feb26d69d7d.png)
 ![fb67fbe674ae8ca2f4c420f15d1d463e.png](../../_resources/fb67fbe674ae8ca2f4c420f15d1d463e.png)
  # <span style="color: blue;">Example 4</span>
  これは Cookie 操作のエクスプロイトですが、ひねりがあり、今回は Cookie の値が暗号化されています   
  ![6020f382c6ddd08fb7fbc765b064260a.png](../../_resources/6020f382c6ddd08fb7fbc765b064260a.png)   
   MD5復号化ソフトウェアを使用して値を見つけ、それを管理者に変更します。   
   ```
   admin:21232f297a57a5a743894a0e4a801fc3
  ```
  ![24dfdfd702be61d2335c855bdb37eee2.png](../../_resources/24dfdfd702be61d2335c855bdb37eee2.png)
  ![ac2b2d60abe95ba5bb0f4e0f5a6d3941.png](../../_resources/ac2b2d60abe95ba5bb0f4e0f5a6d3941.png)
  
  # <span style="color: blue;">Example 5</span>
  この例では、文字列比較の方法を変えた場合の結果を示しています。ユーザーを作成するとき、アプリケーションは与えられたユーザー名を既存のユーザーと比較することで、そのユーザーが存在しないことをプログラムでチェックします。ログインするとき、アプリケーションはユーザー名とパスワードが正しいかどうかをチェックし、ユーザー名をセッションに保存します。最後に、アプリケーションにアクセスするたびに、アプリケーションはセッションで提供されたユーザー名に基づいてユーザーの詳細を取得します。

ここでのトリックは、==ユーザーを作成するときの比較はプログラム的に（つまりRubyで）== 行われますが、==ユーザーの詳細を取得するときの比較はデータベース== によって行われるという事実に由来します。デフォルトでは、==MySQL (VARCHAR型) は大文字小文字を区別せずに比較==を行います。"admin" と "Admin" は同じ値です。

この情報を使って、adminとして識別されるユーザーを作成することができるはずです。   
Username：Adminを登録
![3d29a0bed67933fef13bf72cda39377b.png](../../_resources/3d29a0bed67933fef13bf72cda39377b.png)   
![beb47c648adaf5efd2863be4975bc60e.png](../../_resources/beb47c648adaf5efd2863be4975bc60e.png)   
AdminでログインしたのにadminでSuccess!!!になる    
![472026dde9991de2e7a949a79e611103.png](../../_resources/472026dde9991de2e7a949a79e611103.png)    
# <span style="color: blue;">Example 6</span>
以前の問題を解決するために、開発者はユーザーの作成時に大文字と小文字を区別して比較することにしました。このチェックは、MySQL が文字列比較を行う方法に基づいて回避することも可能です。==MySQLは末尾のスペースを無視==します（例：pentesterlabとpentesterlabは等しい）。上記と同じ方法で、adminというユーザーでログインしているふりをすることができるはずです。   
adminの後にスペースを入れて登録
![a8465929698edf28abd4201c49f65785.png](../../_resources/a8465929698edf28abd4201c49f65785.png)
admin＋スペースでログイン
![a9ee0a221149be5bc771ddbb25f3a99f.png](../../_resources/a9ee0a221149be5bc771ddbb25f3a99f.png)
![d88c8ca3d383528ca2db4b18a5e620c8.png](../../_resources/d88c8ca3d383528ca2db4b18a5e620c8.png)

